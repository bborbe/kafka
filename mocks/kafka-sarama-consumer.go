// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM/sarama"
	"github.com/bborbe/kafka"
)

type KafkaSaramaConsumer struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ConsumePartitionStub        func(string, int32, int64) (sarama.PartitionConsumer, error)
	consumePartitionMutex       sync.RWMutex
	consumePartitionArgsForCall []struct {
		arg1 string
		arg2 int32
		arg3 int64
	}
	consumePartitionReturns struct {
		result1 sarama.PartitionConsumer
		result2 error
	}
	consumePartitionReturnsOnCall map[int]struct {
		result1 sarama.PartitionConsumer
		result2 error
	}
	HighWaterMarksStub        func() map[string]map[int32]int64
	highWaterMarksMutex       sync.RWMutex
	highWaterMarksArgsForCall []struct {
	}
	highWaterMarksReturns struct {
		result1 map[string]map[int32]int64
	}
	highWaterMarksReturnsOnCall map[int]struct {
		result1 map[string]map[int32]int64
	}
	PartitionsStub        func(string) ([]int32, error)
	partitionsMutex       sync.RWMutex
	partitionsArgsForCall []struct {
		arg1 string
	}
	partitionsReturns struct {
		result1 []int32
		result2 error
	}
	partitionsReturnsOnCall map[int]struct {
		result1 []int32
		result2 error
	}
	PauseStub        func(map[string][]int32)
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct {
		arg1 map[string][]int32
	}
	PauseAllStub        func()
	pauseAllMutex       sync.RWMutex
	pauseAllArgsForCall []struct {
	}
	ResumeStub        func(map[string][]int32)
	resumeMutex       sync.RWMutex
	resumeArgsForCall []struct {
		arg1 map[string][]int32
	}
	ResumeAllStub        func()
	resumeAllMutex       sync.RWMutex
	resumeAllArgsForCall []struct {
	}
	TopicsStub        func() ([]string, error)
	topicsMutex       sync.RWMutex
	topicsArgsForCall []struct {
	}
	topicsReturns struct {
		result1 []string
		result2 error
	}
	topicsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *KafkaSaramaConsumer) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaConsumer) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *KafkaSaramaConsumer) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *KafkaSaramaConsumer) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaConsumer) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaConsumer) ConsumePartition(arg1 string, arg2 int32, arg3 int64) (sarama.PartitionConsumer, error) {
	fake.consumePartitionMutex.Lock()
	ret, specificReturn := fake.consumePartitionReturnsOnCall[len(fake.consumePartitionArgsForCall)]
	fake.consumePartitionArgsForCall = append(fake.consumePartitionArgsForCall, struct {
		arg1 string
		arg2 int32
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.ConsumePartitionStub
	fakeReturns := fake.consumePartitionReturns
	fake.recordInvocation("ConsumePartition", []interface{}{arg1, arg2, arg3})
	fake.consumePartitionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaConsumer) ConsumePartitionCallCount() int {
	fake.consumePartitionMutex.RLock()
	defer fake.consumePartitionMutex.RUnlock()
	return len(fake.consumePartitionArgsForCall)
}

func (fake *KafkaSaramaConsumer) ConsumePartitionCalls(stub func(string, int32, int64) (sarama.PartitionConsumer, error)) {
	fake.consumePartitionMutex.Lock()
	defer fake.consumePartitionMutex.Unlock()
	fake.ConsumePartitionStub = stub
}

func (fake *KafkaSaramaConsumer) ConsumePartitionArgsForCall(i int) (string, int32, int64) {
	fake.consumePartitionMutex.RLock()
	defer fake.consumePartitionMutex.RUnlock()
	argsForCall := fake.consumePartitionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *KafkaSaramaConsumer) ConsumePartitionReturns(result1 sarama.PartitionConsumer, result2 error) {
	fake.consumePartitionMutex.Lock()
	defer fake.consumePartitionMutex.Unlock()
	fake.ConsumePartitionStub = nil
	fake.consumePartitionReturns = struct {
		result1 sarama.PartitionConsumer
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaConsumer) ConsumePartitionReturnsOnCall(i int, result1 sarama.PartitionConsumer, result2 error) {
	fake.consumePartitionMutex.Lock()
	defer fake.consumePartitionMutex.Unlock()
	fake.ConsumePartitionStub = nil
	if fake.consumePartitionReturnsOnCall == nil {
		fake.consumePartitionReturnsOnCall = make(map[int]struct {
			result1 sarama.PartitionConsumer
			result2 error
		})
	}
	fake.consumePartitionReturnsOnCall[i] = struct {
		result1 sarama.PartitionConsumer
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaConsumer) HighWaterMarks() map[string]map[int32]int64 {
	fake.highWaterMarksMutex.Lock()
	ret, specificReturn := fake.highWaterMarksReturnsOnCall[len(fake.highWaterMarksArgsForCall)]
	fake.highWaterMarksArgsForCall = append(fake.highWaterMarksArgsForCall, struct {
	}{})
	stub := fake.HighWaterMarksStub
	fakeReturns := fake.highWaterMarksReturns
	fake.recordInvocation("HighWaterMarks", []interface{}{})
	fake.highWaterMarksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaConsumer) HighWaterMarksCallCount() int {
	fake.highWaterMarksMutex.RLock()
	defer fake.highWaterMarksMutex.RUnlock()
	return len(fake.highWaterMarksArgsForCall)
}

func (fake *KafkaSaramaConsumer) HighWaterMarksCalls(stub func() map[string]map[int32]int64) {
	fake.highWaterMarksMutex.Lock()
	defer fake.highWaterMarksMutex.Unlock()
	fake.HighWaterMarksStub = stub
}

func (fake *KafkaSaramaConsumer) HighWaterMarksReturns(result1 map[string]map[int32]int64) {
	fake.highWaterMarksMutex.Lock()
	defer fake.highWaterMarksMutex.Unlock()
	fake.HighWaterMarksStub = nil
	fake.highWaterMarksReturns = struct {
		result1 map[string]map[int32]int64
	}{result1}
}

func (fake *KafkaSaramaConsumer) HighWaterMarksReturnsOnCall(i int, result1 map[string]map[int32]int64) {
	fake.highWaterMarksMutex.Lock()
	defer fake.highWaterMarksMutex.Unlock()
	fake.HighWaterMarksStub = nil
	if fake.highWaterMarksReturnsOnCall == nil {
		fake.highWaterMarksReturnsOnCall = make(map[int]struct {
			result1 map[string]map[int32]int64
		})
	}
	fake.highWaterMarksReturnsOnCall[i] = struct {
		result1 map[string]map[int32]int64
	}{result1}
}

func (fake *KafkaSaramaConsumer) Partitions(arg1 string) ([]int32, error) {
	fake.partitionsMutex.Lock()
	ret, specificReturn := fake.partitionsReturnsOnCall[len(fake.partitionsArgsForCall)]
	fake.partitionsArgsForCall = append(fake.partitionsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PartitionsStub
	fakeReturns := fake.partitionsReturns
	fake.recordInvocation("Partitions", []interface{}{arg1})
	fake.partitionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaConsumer) PartitionsCallCount() int {
	fake.partitionsMutex.RLock()
	defer fake.partitionsMutex.RUnlock()
	return len(fake.partitionsArgsForCall)
}

func (fake *KafkaSaramaConsumer) PartitionsCalls(stub func(string) ([]int32, error)) {
	fake.partitionsMutex.Lock()
	defer fake.partitionsMutex.Unlock()
	fake.PartitionsStub = stub
}

func (fake *KafkaSaramaConsumer) PartitionsArgsForCall(i int) string {
	fake.partitionsMutex.RLock()
	defer fake.partitionsMutex.RUnlock()
	argsForCall := fake.partitionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaConsumer) PartitionsReturns(result1 []int32, result2 error) {
	fake.partitionsMutex.Lock()
	defer fake.partitionsMutex.Unlock()
	fake.PartitionsStub = nil
	fake.partitionsReturns = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaConsumer) PartitionsReturnsOnCall(i int, result1 []int32, result2 error) {
	fake.partitionsMutex.Lock()
	defer fake.partitionsMutex.Unlock()
	fake.PartitionsStub = nil
	if fake.partitionsReturnsOnCall == nil {
		fake.partitionsReturnsOnCall = make(map[int]struct {
			result1 []int32
			result2 error
		})
	}
	fake.partitionsReturnsOnCall[i] = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaConsumer) Pause(arg1 map[string][]int32) {
	fake.pauseMutex.Lock()
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct {
		arg1 map[string][]int32
	}{arg1})
	stub := fake.PauseStub
	fake.recordInvocation("Pause", []interface{}{arg1})
	fake.pauseMutex.Unlock()
	if stub != nil {
		fake.PauseStub(arg1)
	}
}

func (fake *KafkaSaramaConsumer) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *KafkaSaramaConsumer) PauseCalls(stub func(map[string][]int32)) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = stub
}

func (fake *KafkaSaramaConsumer) PauseArgsForCall(i int) map[string][]int32 {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	argsForCall := fake.pauseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaConsumer) PauseAll() {
	fake.pauseAllMutex.Lock()
	fake.pauseAllArgsForCall = append(fake.pauseAllArgsForCall, struct {
	}{})
	stub := fake.PauseAllStub
	fake.recordInvocation("PauseAll", []interface{}{})
	fake.pauseAllMutex.Unlock()
	if stub != nil {
		fake.PauseAllStub()
	}
}

func (fake *KafkaSaramaConsumer) PauseAllCallCount() int {
	fake.pauseAllMutex.RLock()
	defer fake.pauseAllMutex.RUnlock()
	return len(fake.pauseAllArgsForCall)
}

func (fake *KafkaSaramaConsumer) PauseAllCalls(stub func()) {
	fake.pauseAllMutex.Lock()
	defer fake.pauseAllMutex.Unlock()
	fake.PauseAllStub = stub
}

func (fake *KafkaSaramaConsumer) Resume(arg1 map[string][]int32) {
	fake.resumeMutex.Lock()
	fake.resumeArgsForCall = append(fake.resumeArgsForCall, struct {
		arg1 map[string][]int32
	}{arg1})
	stub := fake.ResumeStub
	fake.recordInvocation("Resume", []interface{}{arg1})
	fake.resumeMutex.Unlock()
	if stub != nil {
		fake.ResumeStub(arg1)
	}
}

func (fake *KafkaSaramaConsumer) ResumeCallCount() int {
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	return len(fake.resumeArgsForCall)
}

func (fake *KafkaSaramaConsumer) ResumeCalls(stub func(map[string][]int32)) {
	fake.resumeMutex.Lock()
	defer fake.resumeMutex.Unlock()
	fake.ResumeStub = stub
}

func (fake *KafkaSaramaConsumer) ResumeArgsForCall(i int) map[string][]int32 {
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	argsForCall := fake.resumeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaConsumer) ResumeAll() {
	fake.resumeAllMutex.Lock()
	fake.resumeAllArgsForCall = append(fake.resumeAllArgsForCall, struct {
	}{})
	stub := fake.ResumeAllStub
	fake.recordInvocation("ResumeAll", []interface{}{})
	fake.resumeAllMutex.Unlock()
	if stub != nil {
		fake.ResumeAllStub()
	}
}

func (fake *KafkaSaramaConsumer) ResumeAllCallCount() int {
	fake.resumeAllMutex.RLock()
	defer fake.resumeAllMutex.RUnlock()
	return len(fake.resumeAllArgsForCall)
}

func (fake *KafkaSaramaConsumer) ResumeAllCalls(stub func()) {
	fake.resumeAllMutex.Lock()
	defer fake.resumeAllMutex.Unlock()
	fake.ResumeAllStub = stub
}

func (fake *KafkaSaramaConsumer) Topics() ([]string, error) {
	fake.topicsMutex.Lock()
	ret, specificReturn := fake.topicsReturnsOnCall[len(fake.topicsArgsForCall)]
	fake.topicsArgsForCall = append(fake.topicsArgsForCall, struct {
	}{})
	stub := fake.TopicsStub
	fakeReturns := fake.topicsReturns
	fake.recordInvocation("Topics", []interface{}{})
	fake.topicsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaConsumer) TopicsCallCount() int {
	fake.topicsMutex.RLock()
	defer fake.topicsMutex.RUnlock()
	return len(fake.topicsArgsForCall)
}

func (fake *KafkaSaramaConsumer) TopicsCalls(stub func() ([]string, error)) {
	fake.topicsMutex.Lock()
	defer fake.topicsMutex.Unlock()
	fake.TopicsStub = stub
}

func (fake *KafkaSaramaConsumer) TopicsReturns(result1 []string, result2 error) {
	fake.topicsMutex.Lock()
	defer fake.topicsMutex.Unlock()
	fake.TopicsStub = nil
	fake.topicsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaConsumer) TopicsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.topicsMutex.Lock()
	defer fake.topicsMutex.Unlock()
	fake.TopicsStub = nil
	if fake.topicsReturnsOnCall == nil {
		fake.topicsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.topicsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaConsumer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.consumePartitionMutex.RLock()
	defer fake.consumePartitionMutex.RUnlock()
	fake.highWaterMarksMutex.RLock()
	defer fake.highWaterMarksMutex.RUnlock()
	fake.partitionsMutex.RLock()
	defer fake.partitionsMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.pauseAllMutex.RLock()
	defer fake.pauseAllMutex.RUnlock()
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	fake.resumeAllMutex.RLock()
	defer fake.resumeAllMutex.RUnlock()
	fake.topicsMutex.RLock()
	defer fake.topicsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *KafkaSaramaConsumer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kafka.SaramaConsumer = new(KafkaSaramaConsumer)
