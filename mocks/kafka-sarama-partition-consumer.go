// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM/sarama"
	"github.com/bborbe/kafka"
)

type KafkaSaramaPartitionConsumer struct {
	AsyncCloseStub        func()
	asyncCloseMutex       sync.RWMutex
	asyncCloseArgsForCall []struct {
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ErrorsStub        func() <-chan *sarama.ConsumerError
	errorsMutex       sync.RWMutex
	errorsArgsForCall []struct {
	}
	errorsReturns struct {
		result1 <-chan *sarama.ConsumerError
	}
	errorsReturnsOnCall map[int]struct {
		result1 <-chan *sarama.ConsumerError
	}
	HighWaterMarkOffsetStub        func() int64
	highWaterMarkOffsetMutex       sync.RWMutex
	highWaterMarkOffsetArgsForCall []struct {
	}
	highWaterMarkOffsetReturns struct {
		result1 int64
	}
	highWaterMarkOffsetReturnsOnCall map[int]struct {
		result1 int64
	}
	IsPausedStub        func() bool
	isPausedMutex       sync.RWMutex
	isPausedArgsForCall []struct {
	}
	isPausedReturns struct {
		result1 bool
	}
	isPausedReturnsOnCall map[int]struct {
		result1 bool
	}
	MessagesStub        func() <-chan *sarama.ConsumerMessage
	messagesMutex       sync.RWMutex
	messagesArgsForCall []struct {
	}
	messagesReturns struct {
		result1 <-chan *sarama.ConsumerMessage
	}
	messagesReturnsOnCall map[int]struct {
		result1 <-chan *sarama.ConsumerMessage
	}
	PauseStub        func()
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct {
	}
	ResumeStub        func()
	resumeMutex       sync.RWMutex
	resumeArgsForCall []struct {
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *KafkaSaramaPartitionConsumer) AsyncClose() {
	fake.asyncCloseMutex.Lock()
	fake.asyncCloseArgsForCall = append(fake.asyncCloseArgsForCall, struct {
	}{})
	stub := fake.AsyncCloseStub
	fake.recordInvocation("AsyncClose", []interface{}{})
	fake.asyncCloseMutex.Unlock()
	if stub != nil {
		fake.AsyncCloseStub()
	}
}

func (fake *KafkaSaramaPartitionConsumer) AsyncCloseCallCount() int {
	fake.asyncCloseMutex.RLock()
	defer fake.asyncCloseMutex.RUnlock()
	return len(fake.asyncCloseArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) AsyncCloseCalls(stub func()) {
	fake.asyncCloseMutex.Lock()
	defer fake.asyncCloseMutex.Unlock()
	fake.AsyncCloseStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaPartitionConsumer) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) Errors() <-chan *sarama.ConsumerError {
	fake.errorsMutex.Lock()
	ret, specificReturn := fake.errorsReturnsOnCall[len(fake.errorsArgsForCall)]
	fake.errorsArgsForCall = append(fake.errorsArgsForCall, struct {
	}{})
	stub := fake.ErrorsStub
	fakeReturns := fake.errorsReturns
	fake.recordInvocation("Errors", []interface{}{})
	fake.errorsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaPartitionConsumer) ErrorsCallCount() int {
	fake.errorsMutex.RLock()
	defer fake.errorsMutex.RUnlock()
	return len(fake.errorsArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) ErrorsCalls(stub func() <-chan *sarama.ConsumerError) {
	fake.errorsMutex.Lock()
	defer fake.errorsMutex.Unlock()
	fake.ErrorsStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) ErrorsReturns(result1 <-chan *sarama.ConsumerError) {
	fake.errorsMutex.Lock()
	defer fake.errorsMutex.Unlock()
	fake.ErrorsStub = nil
	fake.errorsReturns = struct {
		result1 <-chan *sarama.ConsumerError
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) ErrorsReturnsOnCall(i int, result1 <-chan *sarama.ConsumerError) {
	fake.errorsMutex.Lock()
	defer fake.errorsMutex.Unlock()
	fake.ErrorsStub = nil
	if fake.errorsReturnsOnCall == nil {
		fake.errorsReturnsOnCall = make(map[int]struct {
			result1 <-chan *sarama.ConsumerError
		})
	}
	fake.errorsReturnsOnCall[i] = struct {
		result1 <-chan *sarama.ConsumerError
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) HighWaterMarkOffset() int64 {
	fake.highWaterMarkOffsetMutex.Lock()
	ret, specificReturn := fake.highWaterMarkOffsetReturnsOnCall[len(fake.highWaterMarkOffsetArgsForCall)]
	fake.highWaterMarkOffsetArgsForCall = append(fake.highWaterMarkOffsetArgsForCall, struct {
	}{})
	stub := fake.HighWaterMarkOffsetStub
	fakeReturns := fake.highWaterMarkOffsetReturns
	fake.recordInvocation("HighWaterMarkOffset", []interface{}{})
	fake.highWaterMarkOffsetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaPartitionConsumer) HighWaterMarkOffsetCallCount() int {
	fake.highWaterMarkOffsetMutex.RLock()
	defer fake.highWaterMarkOffsetMutex.RUnlock()
	return len(fake.highWaterMarkOffsetArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) HighWaterMarkOffsetCalls(stub func() int64) {
	fake.highWaterMarkOffsetMutex.Lock()
	defer fake.highWaterMarkOffsetMutex.Unlock()
	fake.HighWaterMarkOffsetStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) HighWaterMarkOffsetReturns(result1 int64) {
	fake.highWaterMarkOffsetMutex.Lock()
	defer fake.highWaterMarkOffsetMutex.Unlock()
	fake.HighWaterMarkOffsetStub = nil
	fake.highWaterMarkOffsetReturns = struct {
		result1 int64
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) HighWaterMarkOffsetReturnsOnCall(i int, result1 int64) {
	fake.highWaterMarkOffsetMutex.Lock()
	defer fake.highWaterMarkOffsetMutex.Unlock()
	fake.HighWaterMarkOffsetStub = nil
	if fake.highWaterMarkOffsetReturnsOnCall == nil {
		fake.highWaterMarkOffsetReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.highWaterMarkOffsetReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) IsPaused() bool {
	fake.isPausedMutex.Lock()
	ret, specificReturn := fake.isPausedReturnsOnCall[len(fake.isPausedArgsForCall)]
	fake.isPausedArgsForCall = append(fake.isPausedArgsForCall, struct {
	}{})
	stub := fake.IsPausedStub
	fakeReturns := fake.isPausedReturns
	fake.recordInvocation("IsPaused", []interface{}{})
	fake.isPausedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaPartitionConsumer) IsPausedCallCount() int {
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	return len(fake.isPausedArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) IsPausedCalls(stub func() bool) {
	fake.isPausedMutex.Lock()
	defer fake.isPausedMutex.Unlock()
	fake.IsPausedStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) IsPausedReturns(result1 bool) {
	fake.isPausedMutex.Lock()
	defer fake.isPausedMutex.Unlock()
	fake.IsPausedStub = nil
	fake.isPausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) IsPausedReturnsOnCall(i int, result1 bool) {
	fake.isPausedMutex.Lock()
	defer fake.isPausedMutex.Unlock()
	fake.IsPausedStub = nil
	if fake.isPausedReturnsOnCall == nil {
		fake.isPausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) Messages() <-chan *sarama.ConsumerMessage {
	fake.messagesMutex.Lock()
	ret, specificReturn := fake.messagesReturnsOnCall[len(fake.messagesArgsForCall)]
	fake.messagesArgsForCall = append(fake.messagesArgsForCall, struct {
	}{})
	stub := fake.MessagesStub
	fakeReturns := fake.messagesReturns
	fake.recordInvocation("Messages", []interface{}{})
	fake.messagesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaPartitionConsumer) MessagesCallCount() int {
	fake.messagesMutex.RLock()
	defer fake.messagesMutex.RUnlock()
	return len(fake.messagesArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) MessagesCalls(stub func() <-chan *sarama.ConsumerMessage) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) MessagesReturns(result1 <-chan *sarama.ConsumerMessage) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = nil
	fake.messagesReturns = struct {
		result1 <-chan *sarama.ConsumerMessage
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) MessagesReturnsOnCall(i int, result1 <-chan *sarama.ConsumerMessage) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = nil
	if fake.messagesReturnsOnCall == nil {
		fake.messagesReturnsOnCall = make(map[int]struct {
			result1 <-chan *sarama.ConsumerMessage
		})
	}
	fake.messagesReturnsOnCall[i] = struct {
		result1 <-chan *sarama.ConsumerMessage
	}{result1}
}

func (fake *KafkaSaramaPartitionConsumer) Pause() {
	fake.pauseMutex.Lock()
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct {
	}{})
	stub := fake.PauseStub
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if stub != nil {
		fake.PauseStub()
	}
}

func (fake *KafkaSaramaPartitionConsumer) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) PauseCalls(stub func()) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) Resume() {
	fake.resumeMutex.Lock()
	fake.resumeArgsForCall = append(fake.resumeArgsForCall, struct {
	}{})
	stub := fake.ResumeStub
	fake.recordInvocation("Resume", []interface{}{})
	fake.resumeMutex.Unlock()
	if stub != nil {
		fake.ResumeStub()
	}
}

func (fake *KafkaSaramaPartitionConsumer) ResumeCallCount() int {
	fake.resumeMutex.RLock()
	defer fake.resumeMutex.RUnlock()
	return len(fake.resumeArgsForCall)
}

func (fake *KafkaSaramaPartitionConsumer) ResumeCalls(stub func()) {
	fake.resumeMutex.Lock()
	defer fake.resumeMutex.Unlock()
	fake.ResumeStub = stub
}

func (fake *KafkaSaramaPartitionConsumer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *KafkaSaramaPartitionConsumer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kafka.SaramaPartitionConsumer = new(KafkaSaramaPartitionConsumer)
