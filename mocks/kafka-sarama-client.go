// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/IBM/sarama"
	"github.com/bborbe/kafka"
)

type KafkaSaramaClient struct {
	BrokerStub        func(int32) (*sarama.Broker, error)
	brokerMutex       sync.RWMutex
	brokerArgsForCall []struct {
		arg1 int32
	}
	brokerReturns struct {
		result1 *sarama.Broker
		result2 error
	}
	brokerReturnsOnCall map[int]struct {
		result1 *sarama.Broker
		result2 error
	}
	BrokersStub        func() []*sarama.Broker
	brokersMutex       sync.RWMutex
	brokersArgsForCall []struct {
	}
	brokersReturns struct {
		result1 []*sarama.Broker
	}
	brokersReturnsOnCall map[int]struct {
		result1 []*sarama.Broker
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	ClosedStub        func() bool
	closedMutex       sync.RWMutex
	closedArgsForCall []struct {
	}
	closedReturns struct {
		result1 bool
	}
	closedReturnsOnCall map[int]struct {
		result1 bool
	}
	ConfigStub        func() *sarama.Config
	configMutex       sync.RWMutex
	configArgsForCall []struct {
	}
	configReturns struct {
		result1 *sarama.Config
	}
	configReturnsOnCall map[int]struct {
		result1 *sarama.Config
	}
	ControllerStub        func() (*sarama.Broker, error)
	controllerMutex       sync.RWMutex
	controllerArgsForCall []struct {
	}
	controllerReturns struct {
		result1 *sarama.Broker
		result2 error
	}
	controllerReturnsOnCall map[int]struct {
		result1 *sarama.Broker
		result2 error
	}
	CoordinatorStub        func(string) (*sarama.Broker, error)
	coordinatorMutex       sync.RWMutex
	coordinatorArgsForCall []struct {
		arg1 string
	}
	coordinatorReturns struct {
		result1 *sarama.Broker
		result2 error
	}
	coordinatorReturnsOnCall map[int]struct {
		result1 *sarama.Broker
		result2 error
	}
	GetOffsetStub        func(string, int32, int64) (int64, error)
	getOffsetMutex       sync.RWMutex
	getOffsetArgsForCall []struct {
		arg1 string
		arg2 int32
		arg3 int64
	}
	getOffsetReturns struct {
		result1 int64
		result2 error
	}
	getOffsetReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	InSyncReplicasStub        func(string, int32) ([]int32, error)
	inSyncReplicasMutex       sync.RWMutex
	inSyncReplicasArgsForCall []struct {
		arg1 string
		arg2 int32
	}
	inSyncReplicasReturns struct {
		result1 []int32
		result2 error
	}
	inSyncReplicasReturnsOnCall map[int]struct {
		result1 []int32
		result2 error
	}
	InitProducerIDStub        func() (*sarama.InitProducerIDResponse, error)
	initProducerIDMutex       sync.RWMutex
	initProducerIDArgsForCall []struct {
	}
	initProducerIDReturns struct {
		result1 *sarama.InitProducerIDResponse
		result2 error
	}
	initProducerIDReturnsOnCall map[int]struct {
		result1 *sarama.InitProducerIDResponse
		result2 error
	}
	LeaderStub        func(string, int32) (*sarama.Broker, error)
	leaderMutex       sync.RWMutex
	leaderArgsForCall []struct {
		arg1 string
		arg2 int32
	}
	leaderReturns struct {
		result1 *sarama.Broker
		result2 error
	}
	leaderReturnsOnCall map[int]struct {
		result1 *sarama.Broker
		result2 error
	}
	LeaderAndEpochStub        func(string, int32) (*sarama.Broker, int32, error)
	leaderAndEpochMutex       sync.RWMutex
	leaderAndEpochArgsForCall []struct {
		arg1 string
		arg2 int32
	}
	leaderAndEpochReturns struct {
		result1 *sarama.Broker
		result2 int32
		result3 error
	}
	leaderAndEpochReturnsOnCall map[int]struct {
		result1 *sarama.Broker
		result2 int32
		result3 error
	}
	LeastLoadedBrokerStub        func() *sarama.Broker
	leastLoadedBrokerMutex       sync.RWMutex
	leastLoadedBrokerArgsForCall []struct {
	}
	leastLoadedBrokerReturns struct {
		result1 *sarama.Broker
	}
	leastLoadedBrokerReturnsOnCall map[int]struct {
		result1 *sarama.Broker
	}
	OfflineReplicasStub        func(string, int32) ([]int32, error)
	offlineReplicasMutex       sync.RWMutex
	offlineReplicasArgsForCall []struct {
		arg1 string
		arg2 int32
	}
	offlineReplicasReturns struct {
		result1 []int32
		result2 error
	}
	offlineReplicasReturnsOnCall map[int]struct {
		result1 []int32
		result2 error
	}
	PartitionNotReadableStub        func(string, int32) bool
	partitionNotReadableMutex       sync.RWMutex
	partitionNotReadableArgsForCall []struct {
		arg1 string
		arg2 int32
	}
	partitionNotReadableReturns struct {
		result1 bool
	}
	partitionNotReadableReturnsOnCall map[int]struct {
		result1 bool
	}
	PartitionsStub        func(string) ([]int32, error)
	partitionsMutex       sync.RWMutex
	partitionsArgsForCall []struct {
		arg1 string
	}
	partitionsReturns struct {
		result1 []int32
		result2 error
	}
	partitionsReturnsOnCall map[int]struct {
		result1 []int32
		result2 error
	}
	RefreshBrokersStub        func([]string) error
	refreshBrokersMutex       sync.RWMutex
	refreshBrokersArgsForCall []struct {
		arg1 []string
	}
	refreshBrokersReturns struct {
		result1 error
	}
	refreshBrokersReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshControllerStub        func() (*sarama.Broker, error)
	refreshControllerMutex       sync.RWMutex
	refreshControllerArgsForCall []struct {
	}
	refreshControllerReturns struct {
		result1 *sarama.Broker
		result2 error
	}
	refreshControllerReturnsOnCall map[int]struct {
		result1 *sarama.Broker
		result2 error
	}
	RefreshCoordinatorStub        func(string) error
	refreshCoordinatorMutex       sync.RWMutex
	refreshCoordinatorArgsForCall []struct {
		arg1 string
	}
	refreshCoordinatorReturns struct {
		result1 error
	}
	refreshCoordinatorReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshMetadataStub        func(...string) error
	refreshMetadataMutex       sync.RWMutex
	refreshMetadataArgsForCall []struct {
		arg1 []string
	}
	refreshMetadataReturns struct {
		result1 error
	}
	refreshMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshTransactionCoordinatorStub        func(string) error
	refreshTransactionCoordinatorMutex       sync.RWMutex
	refreshTransactionCoordinatorArgsForCall []struct {
		arg1 string
	}
	refreshTransactionCoordinatorReturns struct {
		result1 error
	}
	refreshTransactionCoordinatorReturnsOnCall map[int]struct {
		result1 error
	}
	ReplicasStub        func(string, int32) ([]int32, error)
	replicasMutex       sync.RWMutex
	replicasArgsForCall []struct {
		arg1 string
		arg2 int32
	}
	replicasReturns struct {
		result1 []int32
		result2 error
	}
	replicasReturnsOnCall map[int]struct {
		result1 []int32
		result2 error
	}
	TopicsStub        func() ([]string, error)
	topicsMutex       sync.RWMutex
	topicsArgsForCall []struct {
	}
	topicsReturns struct {
		result1 []string
		result2 error
	}
	topicsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	TransactionCoordinatorStub        func(string) (*sarama.Broker, error)
	transactionCoordinatorMutex       sync.RWMutex
	transactionCoordinatorArgsForCall []struct {
		arg1 string
	}
	transactionCoordinatorReturns struct {
		result1 *sarama.Broker
		result2 error
	}
	transactionCoordinatorReturnsOnCall map[int]struct {
		result1 *sarama.Broker
		result2 error
	}
	WritablePartitionsStub        func(string) ([]int32, error)
	writablePartitionsMutex       sync.RWMutex
	writablePartitionsArgsForCall []struct {
		arg1 string
	}
	writablePartitionsReturns struct {
		result1 []int32
		result2 error
	}
	writablePartitionsReturnsOnCall map[int]struct {
		result1 []int32
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *KafkaSaramaClient) Broker(arg1 int32) (*sarama.Broker, error) {
	fake.brokerMutex.Lock()
	ret, specificReturn := fake.brokerReturnsOnCall[len(fake.brokerArgsForCall)]
	fake.brokerArgsForCall = append(fake.brokerArgsForCall, struct {
		arg1 int32
	}{arg1})
	stub := fake.BrokerStub
	fakeReturns := fake.brokerReturns
	fake.recordInvocation("Broker", []interface{}{arg1})
	fake.brokerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) BrokerCallCount() int {
	fake.brokerMutex.RLock()
	defer fake.brokerMutex.RUnlock()
	return len(fake.brokerArgsForCall)
}

func (fake *KafkaSaramaClient) BrokerCalls(stub func(int32) (*sarama.Broker, error)) {
	fake.brokerMutex.Lock()
	defer fake.brokerMutex.Unlock()
	fake.BrokerStub = stub
}

func (fake *KafkaSaramaClient) BrokerArgsForCall(i int) int32 {
	fake.brokerMutex.RLock()
	defer fake.brokerMutex.RUnlock()
	argsForCall := fake.brokerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) BrokerReturns(result1 *sarama.Broker, result2 error) {
	fake.brokerMutex.Lock()
	defer fake.brokerMutex.Unlock()
	fake.BrokerStub = nil
	fake.brokerReturns = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) BrokerReturnsOnCall(i int, result1 *sarama.Broker, result2 error) {
	fake.brokerMutex.Lock()
	defer fake.brokerMutex.Unlock()
	fake.BrokerStub = nil
	if fake.brokerReturnsOnCall == nil {
		fake.brokerReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
			result2 error
		})
	}
	fake.brokerReturnsOnCall[i] = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) Brokers() []*sarama.Broker {
	fake.brokersMutex.Lock()
	ret, specificReturn := fake.brokersReturnsOnCall[len(fake.brokersArgsForCall)]
	fake.brokersArgsForCall = append(fake.brokersArgsForCall, struct {
	}{})
	stub := fake.BrokersStub
	fakeReturns := fake.brokersReturns
	fake.recordInvocation("Brokers", []interface{}{})
	fake.brokersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) BrokersCallCount() int {
	fake.brokersMutex.RLock()
	defer fake.brokersMutex.RUnlock()
	return len(fake.brokersArgsForCall)
}

func (fake *KafkaSaramaClient) BrokersCalls(stub func() []*sarama.Broker) {
	fake.brokersMutex.Lock()
	defer fake.brokersMutex.Unlock()
	fake.BrokersStub = stub
}

func (fake *KafkaSaramaClient) BrokersReturns(result1 []*sarama.Broker) {
	fake.brokersMutex.Lock()
	defer fake.brokersMutex.Unlock()
	fake.BrokersStub = nil
	fake.brokersReturns = struct {
		result1 []*sarama.Broker
	}{result1}
}

func (fake *KafkaSaramaClient) BrokersReturnsOnCall(i int, result1 []*sarama.Broker) {
	fake.brokersMutex.Lock()
	defer fake.brokersMutex.Unlock()
	fake.BrokersStub = nil
	if fake.brokersReturnsOnCall == nil {
		fake.brokersReturnsOnCall = make(map[int]struct {
			result1 []*sarama.Broker
		})
	}
	fake.brokersReturnsOnCall[i] = struct {
		result1 []*sarama.Broker
	}{result1}
}

func (fake *KafkaSaramaClient) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *KafkaSaramaClient) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *KafkaSaramaClient) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) Closed() bool {
	fake.closedMutex.Lock()
	ret, specificReturn := fake.closedReturnsOnCall[len(fake.closedArgsForCall)]
	fake.closedArgsForCall = append(fake.closedArgsForCall, struct {
	}{})
	stub := fake.ClosedStub
	fakeReturns := fake.closedReturns
	fake.recordInvocation("Closed", []interface{}{})
	fake.closedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) ClosedCallCount() int {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	return len(fake.closedArgsForCall)
}

func (fake *KafkaSaramaClient) ClosedCalls(stub func() bool) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = stub
}

func (fake *KafkaSaramaClient) ClosedReturns(result1 bool) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = nil
	fake.closedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *KafkaSaramaClient) ClosedReturnsOnCall(i int, result1 bool) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = nil
	if fake.closedReturnsOnCall == nil {
		fake.closedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.closedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *KafkaSaramaClient) Config() *sarama.Config {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct {
	}{})
	stub := fake.ConfigStub
	fakeReturns := fake.configReturns
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *KafkaSaramaClient) ConfigCalls(stub func() *sarama.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = stub
}

func (fake *KafkaSaramaClient) ConfigReturns(result1 *sarama.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 *sarama.Config
	}{result1}
}

func (fake *KafkaSaramaClient) ConfigReturnsOnCall(i int, result1 *sarama.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 *sarama.Config
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 *sarama.Config
	}{result1}
}

func (fake *KafkaSaramaClient) Controller() (*sarama.Broker, error) {
	fake.controllerMutex.Lock()
	ret, specificReturn := fake.controllerReturnsOnCall[len(fake.controllerArgsForCall)]
	fake.controllerArgsForCall = append(fake.controllerArgsForCall, struct {
	}{})
	stub := fake.ControllerStub
	fakeReturns := fake.controllerReturns
	fake.recordInvocation("Controller", []interface{}{})
	fake.controllerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) ControllerCallCount() int {
	fake.controllerMutex.RLock()
	defer fake.controllerMutex.RUnlock()
	return len(fake.controllerArgsForCall)
}

func (fake *KafkaSaramaClient) ControllerCalls(stub func() (*sarama.Broker, error)) {
	fake.controllerMutex.Lock()
	defer fake.controllerMutex.Unlock()
	fake.ControllerStub = stub
}

func (fake *KafkaSaramaClient) ControllerReturns(result1 *sarama.Broker, result2 error) {
	fake.controllerMutex.Lock()
	defer fake.controllerMutex.Unlock()
	fake.ControllerStub = nil
	fake.controllerReturns = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) ControllerReturnsOnCall(i int, result1 *sarama.Broker, result2 error) {
	fake.controllerMutex.Lock()
	defer fake.controllerMutex.Unlock()
	fake.ControllerStub = nil
	if fake.controllerReturnsOnCall == nil {
		fake.controllerReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
			result2 error
		})
	}
	fake.controllerReturnsOnCall[i] = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) Coordinator(arg1 string) (*sarama.Broker, error) {
	fake.coordinatorMutex.Lock()
	ret, specificReturn := fake.coordinatorReturnsOnCall[len(fake.coordinatorArgsForCall)]
	fake.coordinatorArgsForCall = append(fake.coordinatorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CoordinatorStub
	fakeReturns := fake.coordinatorReturns
	fake.recordInvocation("Coordinator", []interface{}{arg1})
	fake.coordinatorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) CoordinatorCallCount() int {
	fake.coordinatorMutex.RLock()
	defer fake.coordinatorMutex.RUnlock()
	return len(fake.coordinatorArgsForCall)
}

func (fake *KafkaSaramaClient) CoordinatorCalls(stub func(string) (*sarama.Broker, error)) {
	fake.coordinatorMutex.Lock()
	defer fake.coordinatorMutex.Unlock()
	fake.CoordinatorStub = stub
}

func (fake *KafkaSaramaClient) CoordinatorArgsForCall(i int) string {
	fake.coordinatorMutex.RLock()
	defer fake.coordinatorMutex.RUnlock()
	argsForCall := fake.coordinatorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) CoordinatorReturns(result1 *sarama.Broker, result2 error) {
	fake.coordinatorMutex.Lock()
	defer fake.coordinatorMutex.Unlock()
	fake.CoordinatorStub = nil
	fake.coordinatorReturns = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) CoordinatorReturnsOnCall(i int, result1 *sarama.Broker, result2 error) {
	fake.coordinatorMutex.Lock()
	defer fake.coordinatorMutex.Unlock()
	fake.CoordinatorStub = nil
	if fake.coordinatorReturnsOnCall == nil {
		fake.coordinatorReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
			result2 error
		})
	}
	fake.coordinatorReturnsOnCall[i] = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) GetOffset(arg1 string, arg2 int32, arg3 int64) (int64, error) {
	fake.getOffsetMutex.Lock()
	ret, specificReturn := fake.getOffsetReturnsOnCall[len(fake.getOffsetArgsForCall)]
	fake.getOffsetArgsForCall = append(fake.getOffsetArgsForCall, struct {
		arg1 string
		arg2 int32
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.GetOffsetStub
	fakeReturns := fake.getOffsetReturns
	fake.recordInvocation("GetOffset", []interface{}{arg1, arg2, arg3})
	fake.getOffsetMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) GetOffsetCallCount() int {
	fake.getOffsetMutex.RLock()
	defer fake.getOffsetMutex.RUnlock()
	return len(fake.getOffsetArgsForCall)
}

func (fake *KafkaSaramaClient) GetOffsetCalls(stub func(string, int32, int64) (int64, error)) {
	fake.getOffsetMutex.Lock()
	defer fake.getOffsetMutex.Unlock()
	fake.GetOffsetStub = stub
}

func (fake *KafkaSaramaClient) GetOffsetArgsForCall(i int) (string, int32, int64) {
	fake.getOffsetMutex.RLock()
	defer fake.getOffsetMutex.RUnlock()
	argsForCall := fake.getOffsetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *KafkaSaramaClient) GetOffsetReturns(result1 int64, result2 error) {
	fake.getOffsetMutex.Lock()
	defer fake.getOffsetMutex.Unlock()
	fake.GetOffsetStub = nil
	fake.getOffsetReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) GetOffsetReturnsOnCall(i int, result1 int64, result2 error) {
	fake.getOffsetMutex.Lock()
	defer fake.getOffsetMutex.Unlock()
	fake.GetOffsetStub = nil
	if fake.getOffsetReturnsOnCall == nil {
		fake.getOffsetReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.getOffsetReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) InSyncReplicas(arg1 string, arg2 int32) ([]int32, error) {
	fake.inSyncReplicasMutex.Lock()
	ret, specificReturn := fake.inSyncReplicasReturnsOnCall[len(fake.inSyncReplicasArgsForCall)]
	fake.inSyncReplicasArgsForCall = append(fake.inSyncReplicasArgsForCall, struct {
		arg1 string
		arg2 int32
	}{arg1, arg2})
	stub := fake.InSyncReplicasStub
	fakeReturns := fake.inSyncReplicasReturns
	fake.recordInvocation("InSyncReplicas", []interface{}{arg1, arg2})
	fake.inSyncReplicasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) InSyncReplicasCallCount() int {
	fake.inSyncReplicasMutex.RLock()
	defer fake.inSyncReplicasMutex.RUnlock()
	return len(fake.inSyncReplicasArgsForCall)
}

func (fake *KafkaSaramaClient) InSyncReplicasCalls(stub func(string, int32) ([]int32, error)) {
	fake.inSyncReplicasMutex.Lock()
	defer fake.inSyncReplicasMutex.Unlock()
	fake.InSyncReplicasStub = stub
}

func (fake *KafkaSaramaClient) InSyncReplicasArgsForCall(i int) (string, int32) {
	fake.inSyncReplicasMutex.RLock()
	defer fake.inSyncReplicasMutex.RUnlock()
	argsForCall := fake.inSyncReplicasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KafkaSaramaClient) InSyncReplicasReturns(result1 []int32, result2 error) {
	fake.inSyncReplicasMutex.Lock()
	defer fake.inSyncReplicasMutex.Unlock()
	fake.InSyncReplicasStub = nil
	fake.inSyncReplicasReturns = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) InSyncReplicasReturnsOnCall(i int, result1 []int32, result2 error) {
	fake.inSyncReplicasMutex.Lock()
	defer fake.inSyncReplicasMutex.Unlock()
	fake.InSyncReplicasStub = nil
	if fake.inSyncReplicasReturnsOnCall == nil {
		fake.inSyncReplicasReturnsOnCall = make(map[int]struct {
			result1 []int32
			result2 error
		})
	}
	fake.inSyncReplicasReturnsOnCall[i] = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) InitProducerID() (*sarama.InitProducerIDResponse, error) {
	fake.initProducerIDMutex.Lock()
	ret, specificReturn := fake.initProducerIDReturnsOnCall[len(fake.initProducerIDArgsForCall)]
	fake.initProducerIDArgsForCall = append(fake.initProducerIDArgsForCall, struct {
	}{})
	stub := fake.InitProducerIDStub
	fakeReturns := fake.initProducerIDReturns
	fake.recordInvocation("InitProducerID", []interface{}{})
	fake.initProducerIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) InitProducerIDCallCount() int {
	fake.initProducerIDMutex.RLock()
	defer fake.initProducerIDMutex.RUnlock()
	return len(fake.initProducerIDArgsForCall)
}

func (fake *KafkaSaramaClient) InitProducerIDCalls(stub func() (*sarama.InitProducerIDResponse, error)) {
	fake.initProducerIDMutex.Lock()
	defer fake.initProducerIDMutex.Unlock()
	fake.InitProducerIDStub = stub
}

func (fake *KafkaSaramaClient) InitProducerIDReturns(result1 *sarama.InitProducerIDResponse, result2 error) {
	fake.initProducerIDMutex.Lock()
	defer fake.initProducerIDMutex.Unlock()
	fake.InitProducerIDStub = nil
	fake.initProducerIDReturns = struct {
		result1 *sarama.InitProducerIDResponse
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) InitProducerIDReturnsOnCall(i int, result1 *sarama.InitProducerIDResponse, result2 error) {
	fake.initProducerIDMutex.Lock()
	defer fake.initProducerIDMutex.Unlock()
	fake.InitProducerIDStub = nil
	if fake.initProducerIDReturnsOnCall == nil {
		fake.initProducerIDReturnsOnCall = make(map[int]struct {
			result1 *sarama.InitProducerIDResponse
			result2 error
		})
	}
	fake.initProducerIDReturnsOnCall[i] = struct {
		result1 *sarama.InitProducerIDResponse
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) Leader(arg1 string, arg2 int32) (*sarama.Broker, error) {
	fake.leaderMutex.Lock()
	ret, specificReturn := fake.leaderReturnsOnCall[len(fake.leaderArgsForCall)]
	fake.leaderArgsForCall = append(fake.leaderArgsForCall, struct {
		arg1 string
		arg2 int32
	}{arg1, arg2})
	stub := fake.LeaderStub
	fakeReturns := fake.leaderReturns
	fake.recordInvocation("Leader", []interface{}{arg1, arg2})
	fake.leaderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) LeaderCallCount() int {
	fake.leaderMutex.RLock()
	defer fake.leaderMutex.RUnlock()
	return len(fake.leaderArgsForCall)
}

func (fake *KafkaSaramaClient) LeaderCalls(stub func(string, int32) (*sarama.Broker, error)) {
	fake.leaderMutex.Lock()
	defer fake.leaderMutex.Unlock()
	fake.LeaderStub = stub
}

func (fake *KafkaSaramaClient) LeaderArgsForCall(i int) (string, int32) {
	fake.leaderMutex.RLock()
	defer fake.leaderMutex.RUnlock()
	argsForCall := fake.leaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KafkaSaramaClient) LeaderReturns(result1 *sarama.Broker, result2 error) {
	fake.leaderMutex.Lock()
	defer fake.leaderMutex.Unlock()
	fake.LeaderStub = nil
	fake.leaderReturns = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) LeaderReturnsOnCall(i int, result1 *sarama.Broker, result2 error) {
	fake.leaderMutex.Lock()
	defer fake.leaderMutex.Unlock()
	fake.LeaderStub = nil
	if fake.leaderReturnsOnCall == nil {
		fake.leaderReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
			result2 error
		})
	}
	fake.leaderReturnsOnCall[i] = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) LeaderAndEpoch(arg1 string, arg2 int32) (*sarama.Broker, int32, error) {
	fake.leaderAndEpochMutex.Lock()
	ret, specificReturn := fake.leaderAndEpochReturnsOnCall[len(fake.leaderAndEpochArgsForCall)]
	fake.leaderAndEpochArgsForCall = append(fake.leaderAndEpochArgsForCall, struct {
		arg1 string
		arg2 int32
	}{arg1, arg2})
	stub := fake.LeaderAndEpochStub
	fakeReturns := fake.leaderAndEpochReturns
	fake.recordInvocation("LeaderAndEpoch", []interface{}{arg1, arg2})
	fake.leaderAndEpochMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *KafkaSaramaClient) LeaderAndEpochCallCount() int {
	fake.leaderAndEpochMutex.RLock()
	defer fake.leaderAndEpochMutex.RUnlock()
	return len(fake.leaderAndEpochArgsForCall)
}

func (fake *KafkaSaramaClient) LeaderAndEpochCalls(stub func(string, int32) (*sarama.Broker, int32, error)) {
	fake.leaderAndEpochMutex.Lock()
	defer fake.leaderAndEpochMutex.Unlock()
	fake.LeaderAndEpochStub = stub
}

func (fake *KafkaSaramaClient) LeaderAndEpochArgsForCall(i int) (string, int32) {
	fake.leaderAndEpochMutex.RLock()
	defer fake.leaderAndEpochMutex.RUnlock()
	argsForCall := fake.leaderAndEpochArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KafkaSaramaClient) LeaderAndEpochReturns(result1 *sarama.Broker, result2 int32, result3 error) {
	fake.leaderAndEpochMutex.Lock()
	defer fake.leaderAndEpochMutex.Unlock()
	fake.LeaderAndEpochStub = nil
	fake.leaderAndEpochReturns = struct {
		result1 *sarama.Broker
		result2 int32
		result3 error
	}{result1, result2, result3}
}

func (fake *KafkaSaramaClient) LeaderAndEpochReturnsOnCall(i int, result1 *sarama.Broker, result2 int32, result3 error) {
	fake.leaderAndEpochMutex.Lock()
	defer fake.leaderAndEpochMutex.Unlock()
	fake.LeaderAndEpochStub = nil
	if fake.leaderAndEpochReturnsOnCall == nil {
		fake.leaderAndEpochReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
			result2 int32
			result3 error
		})
	}
	fake.leaderAndEpochReturnsOnCall[i] = struct {
		result1 *sarama.Broker
		result2 int32
		result3 error
	}{result1, result2, result3}
}

func (fake *KafkaSaramaClient) LeastLoadedBroker() *sarama.Broker {
	fake.leastLoadedBrokerMutex.Lock()
	ret, specificReturn := fake.leastLoadedBrokerReturnsOnCall[len(fake.leastLoadedBrokerArgsForCall)]
	fake.leastLoadedBrokerArgsForCall = append(fake.leastLoadedBrokerArgsForCall, struct {
	}{})
	stub := fake.LeastLoadedBrokerStub
	fakeReturns := fake.leastLoadedBrokerReturns
	fake.recordInvocation("LeastLoadedBroker", []interface{}{})
	fake.leastLoadedBrokerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) LeastLoadedBrokerCallCount() int {
	fake.leastLoadedBrokerMutex.RLock()
	defer fake.leastLoadedBrokerMutex.RUnlock()
	return len(fake.leastLoadedBrokerArgsForCall)
}

func (fake *KafkaSaramaClient) LeastLoadedBrokerCalls(stub func() *sarama.Broker) {
	fake.leastLoadedBrokerMutex.Lock()
	defer fake.leastLoadedBrokerMutex.Unlock()
	fake.LeastLoadedBrokerStub = stub
}

func (fake *KafkaSaramaClient) LeastLoadedBrokerReturns(result1 *sarama.Broker) {
	fake.leastLoadedBrokerMutex.Lock()
	defer fake.leastLoadedBrokerMutex.Unlock()
	fake.LeastLoadedBrokerStub = nil
	fake.leastLoadedBrokerReturns = struct {
		result1 *sarama.Broker
	}{result1}
}

func (fake *KafkaSaramaClient) LeastLoadedBrokerReturnsOnCall(i int, result1 *sarama.Broker) {
	fake.leastLoadedBrokerMutex.Lock()
	defer fake.leastLoadedBrokerMutex.Unlock()
	fake.LeastLoadedBrokerStub = nil
	if fake.leastLoadedBrokerReturnsOnCall == nil {
		fake.leastLoadedBrokerReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
		})
	}
	fake.leastLoadedBrokerReturnsOnCall[i] = struct {
		result1 *sarama.Broker
	}{result1}
}

func (fake *KafkaSaramaClient) OfflineReplicas(arg1 string, arg2 int32) ([]int32, error) {
	fake.offlineReplicasMutex.Lock()
	ret, specificReturn := fake.offlineReplicasReturnsOnCall[len(fake.offlineReplicasArgsForCall)]
	fake.offlineReplicasArgsForCall = append(fake.offlineReplicasArgsForCall, struct {
		arg1 string
		arg2 int32
	}{arg1, arg2})
	stub := fake.OfflineReplicasStub
	fakeReturns := fake.offlineReplicasReturns
	fake.recordInvocation("OfflineReplicas", []interface{}{arg1, arg2})
	fake.offlineReplicasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) OfflineReplicasCallCount() int {
	fake.offlineReplicasMutex.RLock()
	defer fake.offlineReplicasMutex.RUnlock()
	return len(fake.offlineReplicasArgsForCall)
}

func (fake *KafkaSaramaClient) OfflineReplicasCalls(stub func(string, int32) ([]int32, error)) {
	fake.offlineReplicasMutex.Lock()
	defer fake.offlineReplicasMutex.Unlock()
	fake.OfflineReplicasStub = stub
}

func (fake *KafkaSaramaClient) OfflineReplicasArgsForCall(i int) (string, int32) {
	fake.offlineReplicasMutex.RLock()
	defer fake.offlineReplicasMutex.RUnlock()
	argsForCall := fake.offlineReplicasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KafkaSaramaClient) OfflineReplicasReturns(result1 []int32, result2 error) {
	fake.offlineReplicasMutex.Lock()
	defer fake.offlineReplicasMutex.Unlock()
	fake.OfflineReplicasStub = nil
	fake.offlineReplicasReturns = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) OfflineReplicasReturnsOnCall(i int, result1 []int32, result2 error) {
	fake.offlineReplicasMutex.Lock()
	defer fake.offlineReplicasMutex.Unlock()
	fake.OfflineReplicasStub = nil
	if fake.offlineReplicasReturnsOnCall == nil {
		fake.offlineReplicasReturnsOnCall = make(map[int]struct {
			result1 []int32
			result2 error
		})
	}
	fake.offlineReplicasReturnsOnCall[i] = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) PartitionNotReadable(arg1 string, arg2 int32) bool {
	fake.partitionNotReadableMutex.Lock()
	ret, specificReturn := fake.partitionNotReadableReturnsOnCall[len(fake.partitionNotReadableArgsForCall)]
	fake.partitionNotReadableArgsForCall = append(fake.partitionNotReadableArgsForCall, struct {
		arg1 string
		arg2 int32
	}{arg1, arg2})
	stub := fake.PartitionNotReadableStub
	fakeReturns := fake.partitionNotReadableReturns
	fake.recordInvocation("PartitionNotReadable", []interface{}{arg1, arg2})
	fake.partitionNotReadableMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) PartitionNotReadableCallCount() int {
	fake.partitionNotReadableMutex.RLock()
	defer fake.partitionNotReadableMutex.RUnlock()
	return len(fake.partitionNotReadableArgsForCall)
}

func (fake *KafkaSaramaClient) PartitionNotReadableCalls(stub func(string, int32) bool) {
	fake.partitionNotReadableMutex.Lock()
	defer fake.partitionNotReadableMutex.Unlock()
	fake.PartitionNotReadableStub = stub
}

func (fake *KafkaSaramaClient) PartitionNotReadableArgsForCall(i int) (string, int32) {
	fake.partitionNotReadableMutex.RLock()
	defer fake.partitionNotReadableMutex.RUnlock()
	argsForCall := fake.partitionNotReadableArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KafkaSaramaClient) PartitionNotReadableReturns(result1 bool) {
	fake.partitionNotReadableMutex.Lock()
	defer fake.partitionNotReadableMutex.Unlock()
	fake.PartitionNotReadableStub = nil
	fake.partitionNotReadableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *KafkaSaramaClient) PartitionNotReadableReturnsOnCall(i int, result1 bool) {
	fake.partitionNotReadableMutex.Lock()
	defer fake.partitionNotReadableMutex.Unlock()
	fake.PartitionNotReadableStub = nil
	if fake.partitionNotReadableReturnsOnCall == nil {
		fake.partitionNotReadableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.partitionNotReadableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *KafkaSaramaClient) Partitions(arg1 string) ([]int32, error) {
	fake.partitionsMutex.Lock()
	ret, specificReturn := fake.partitionsReturnsOnCall[len(fake.partitionsArgsForCall)]
	fake.partitionsArgsForCall = append(fake.partitionsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.PartitionsStub
	fakeReturns := fake.partitionsReturns
	fake.recordInvocation("Partitions", []interface{}{arg1})
	fake.partitionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) PartitionsCallCount() int {
	fake.partitionsMutex.RLock()
	defer fake.partitionsMutex.RUnlock()
	return len(fake.partitionsArgsForCall)
}

func (fake *KafkaSaramaClient) PartitionsCalls(stub func(string) ([]int32, error)) {
	fake.partitionsMutex.Lock()
	defer fake.partitionsMutex.Unlock()
	fake.PartitionsStub = stub
}

func (fake *KafkaSaramaClient) PartitionsArgsForCall(i int) string {
	fake.partitionsMutex.RLock()
	defer fake.partitionsMutex.RUnlock()
	argsForCall := fake.partitionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) PartitionsReturns(result1 []int32, result2 error) {
	fake.partitionsMutex.Lock()
	defer fake.partitionsMutex.Unlock()
	fake.PartitionsStub = nil
	fake.partitionsReturns = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) PartitionsReturnsOnCall(i int, result1 []int32, result2 error) {
	fake.partitionsMutex.Lock()
	defer fake.partitionsMutex.Unlock()
	fake.PartitionsStub = nil
	if fake.partitionsReturnsOnCall == nil {
		fake.partitionsReturnsOnCall = make(map[int]struct {
			result1 []int32
			result2 error
		})
	}
	fake.partitionsReturnsOnCall[i] = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) RefreshBrokers(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.refreshBrokersMutex.Lock()
	ret, specificReturn := fake.refreshBrokersReturnsOnCall[len(fake.refreshBrokersArgsForCall)]
	fake.refreshBrokersArgsForCall = append(fake.refreshBrokersArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.RefreshBrokersStub
	fakeReturns := fake.refreshBrokersReturns
	fake.recordInvocation("RefreshBrokers", []interface{}{arg1Copy})
	fake.refreshBrokersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) RefreshBrokersCallCount() int {
	fake.refreshBrokersMutex.RLock()
	defer fake.refreshBrokersMutex.RUnlock()
	return len(fake.refreshBrokersArgsForCall)
}

func (fake *KafkaSaramaClient) RefreshBrokersCalls(stub func([]string) error) {
	fake.refreshBrokersMutex.Lock()
	defer fake.refreshBrokersMutex.Unlock()
	fake.RefreshBrokersStub = stub
}

func (fake *KafkaSaramaClient) RefreshBrokersArgsForCall(i int) []string {
	fake.refreshBrokersMutex.RLock()
	defer fake.refreshBrokersMutex.RUnlock()
	argsForCall := fake.refreshBrokersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) RefreshBrokersReturns(result1 error) {
	fake.refreshBrokersMutex.Lock()
	defer fake.refreshBrokersMutex.Unlock()
	fake.RefreshBrokersStub = nil
	fake.refreshBrokersReturns = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) RefreshBrokersReturnsOnCall(i int, result1 error) {
	fake.refreshBrokersMutex.Lock()
	defer fake.refreshBrokersMutex.Unlock()
	fake.RefreshBrokersStub = nil
	if fake.refreshBrokersReturnsOnCall == nil {
		fake.refreshBrokersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshBrokersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) RefreshController() (*sarama.Broker, error) {
	fake.refreshControllerMutex.Lock()
	ret, specificReturn := fake.refreshControllerReturnsOnCall[len(fake.refreshControllerArgsForCall)]
	fake.refreshControllerArgsForCall = append(fake.refreshControllerArgsForCall, struct {
	}{})
	stub := fake.RefreshControllerStub
	fakeReturns := fake.refreshControllerReturns
	fake.recordInvocation("RefreshController", []interface{}{})
	fake.refreshControllerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) RefreshControllerCallCount() int {
	fake.refreshControllerMutex.RLock()
	defer fake.refreshControllerMutex.RUnlock()
	return len(fake.refreshControllerArgsForCall)
}

func (fake *KafkaSaramaClient) RefreshControllerCalls(stub func() (*sarama.Broker, error)) {
	fake.refreshControllerMutex.Lock()
	defer fake.refreshControllerMutex.Unlock()
	fake.RefreshControllerStub = stub
}

func (fake *KafkaSaramaClient) RefreshControllerReturns(result1 *sarama.Broker, result2 error) {
	fake.refreshControllerMutex.Lock()
	defer fake.refreshControllerMutex.Unlock()
	fake.RefreshControllerStub = nil
	fake.refreshControllerReturns = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) RefreshControllerReturnsOnCall(i int, result1 *sarama.Broker, result2 error) {
	fake.refreshControllerMutex.Lock()
	defer fake.refreshControllerMutex.Unlock()
	fake.RefreshControllerStub = nil
	if fake.refreshControllerReturnsOnCall == nil {
		fake.refreshControllerReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
			result2 error
		})
	}
	fake.refreshControllerReturnsOnCall[i] = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) RefreshCoordinator(arg1 string) error {
	fake.refreshCoordinatorMutex.Lock()
	ret, specificReturn := fake.refreshCoordinatorReturnsOnCall[len(fake.refreshCoordinatorArgsForCall)]
	fake.refreshCoordinatorArgsForCall = append(fake.refreshCoordinatorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RefreshCoordinatorStub
	fakeReturns := fake.refreshCoordinatorReturns
	fake.recordInvocation("RefreshCoordinator", []interface{}{arg1})
	fake.refreshCoordinatorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) RefreshCoordinatorCallCount() int {
	fake.refreshCoordinatorMutex.RLock()
	defer fake.refreshCoordinatorMutex.RUnlock()
	return len(fake.refreshCoordinatorArgsForCall)
}

func (fake *KafkaSaramaClient) RefreshCoordinatorCalls(stub func(string) error) {
	fake.refreshCoordinatorMutex.Lock()
	defer fake.refreshCoordinatorMutex.Unlock()
	fake.RefreshCoordinatorStub = stub
}

func (fake *KafkaSaramaClient) RefreshCoordinatorArgsForCall(i int) string {
	fake.refreshCoordinatorMutex.RLock()
	defer fake.refreshCoordinatorMutex.RUnlock()
	argsForCall := fake.refreshCoordinatorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) RefreshCoordinatorReturns(result1 error) {
	fake.refreshCoordinatorMutex.Lock()
	defer fake.refreshCoordinatorMutex.Unlock()
	fake.RefreshCoordinatorStub = nil
	fake.refreshCoordinatorReturns = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) RefreshCoordinatorReturnsOnCall(i int, result1 error) {
	fake.refreshCoordinatorMutex.Lock()
	defer fake.refreshCoordinatorMutex.Unlock()
	fake.RefreshCoordinatorStub = nil
	if fake.refreshCoordinatorReturnsOnCall == nil {
		fake.refreshCoordinatorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshCoordinatorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) RefreshMetadata(arg1 ...string) error {
	fake.refreshMetadataMutex.Lock()
	ret, specificReturn := fake.refreshMetadataReturnsOnCall[len(fake.refreshMetadataArgsForCall)]
	fake.refreshMetadataArgsForCall = append(fake.refreshMetadataArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.RefreshMetadataStub
	fakeReturns := fake.refreshMetadataReturns
	fake.recordInvocation("RefreshMetadata", []interface{}{arg1})
	fake.refreshMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) RefreshMetadataCallCount() int {
	fake.refreshMetadataMutex.RLock()
	defer fake.refreshMetadataMutex.RUnlock()
	return len(fake.refreshMetadataArgsForCall)
}

func (fake *KafkaSaramaClient) RefreshMetadataCalls(stub func(...string) error) {
	fake.refreshMetadataMutex.Lock()
	defer fake.refreshMetadataMutex.Unlock()
	fake.RefreshMetadataStub = stub
}

func (fake *KafkaSaramaClient) RefreshMetadataArgsForCall(i int) []string {
	fake.refreshMetadataMutex.RLock()
	defer fake.refreshMetadataMutex.RUnlock()
	argsForCall := fake.refreshMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) RefreshMetadataReturns(result1 error) {
	fake.refreshMetadataMutex.Lock()
	defer fake.refreshMetadataMutex.Unlock()
	fake.RefreshMetadataStub = nil
	fake.refreshMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) RefreshMetadataReturnsOnCall(i int, result1 error) {
	fake.refreshMetadataMutex.Lock()
	defer fake.refreshMetadataMutex.Unlock()
	fake.RefreshMetadataStub = nil
	if fake.refreshMetadataReturnsOnCall == nil {
		fake.refreshMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) RefreshTransactionCoordinator(arg1 string) error {
	fake.refreshTransactionCoordinatorMutex.Lock()
	ret, specificReturn := fake.refreshTransactionCoordinatorReturnsOnCall[len(fake.refreshTransactionCoordinatorArgsForCall)]
	fake.refreshTransactionCoordinatorArgsForCall = append(fake.refreshTransactionCoordinatorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RefreshTransactionCoordinatorStub
	fakeReturns := fake.refreshTransactionCoordinatorReturns
	fake.recordInvocation("RefreshTransactionCoordinator", []interface{}{arg1})
	fake.refreshTransactionCoordinatorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *KafkaSaramaClient) RefreshTransactionCoordinatorCallCount() int {
	fake.refreshTransactionCoordinatorMutex.RLock()
	defer fake.refreshTransactionCoordinatorMutex.RUnlock()
	return len(fake.refreshTransactionCoordinatorArgsForCall)
}

func (fake *KafkaSaramaClient) RefreshTransactionCoordinatorCalls(stub func(string) error) {
	fake.refreshTransactionCoordinatorMutex.Lock()
	defer fake.refreshTransactionCoordinatorMutex.Unlock()
	fake.RefreshTransactionCoordinatorStub = stub
}

func (fake *KafkaSaramaClient) RefreshTransactionCoordinatorArgsForCall(i int) string {
	fake.refreshTransactionCoordinatorMutex.RLock()
	defer fake.refreshTransactionCoordinatorMutex.RUnlock()
	argsForCall := fake.refreshTransactionCoordinatorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) RefreshTransactionCoordinatorReturns(result1 error) {
	fake.refreshTransactionCoordinatorMutex.Lock()
	defer fake.refreshTransactionCoordinatorMutex.Unlock()
	fake.RefreshTransactionCoordinatorStub = nil
	fake.refreshTransactionCoordinatorReturns = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) RefreshTransactionCoordinatorReturnsOnCall(i int, result1 error) {
	fake.refreshTransactionCoordinatorMutex.Lock()
	defer fake.refreshTransactionCoordinatorMutex.Unlock()
	fake.RefreshTransactionCoordinatorStub = nil
	if fake.refreshTransactionCoordinatorReturnsOnCall == nil {
		fake.refreshTransactionCoordinatorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshTransactionCoordinatorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *KafkaSaramaClient) Replicas(arg1 string, arg2 int32) ([]int32, error) {
	fake.replicasMutex.Lock()
	ret, specificReturn := fake.replicasReturnsOnCall[len(fake.replicasArgsForCall)]
	fake.replicasArgsForCall = append(fake.replicasArgsForCall, struct {
		arg1 string
		arg2 int32
	}{arg1, arg2})
	stub := fake.ReplicasStub
	fakeReturns := fake.replicasReturns
	fake.recordInvocation("Replicas", []interface{}{arg1, arg2})
	fake.replicasMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) ReplicasCallCount() int {
	fake.replicasMutex.RLock()
	defer fake.replicasMutex.RUnlock()
	return len(fake.replicasArgsForCall)
}

func (fake *KafkaSaramaClient) ReplicasCalls(stub func(string, int32) ([]int32, error)) {
	fake.replicasMutex.Lock()
	defer fake.replicasMutex.Unlock()
	fake.ReplicasStub = stub
}

func (fake *KafkaSaramaClient) ReplicasArgsForCall(i int) (string, int32) {
	fake.replicasMutex.RLock()
	defer fake.replicasMutex.RUnlock()
	argsForCall := fake.replicasArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *KafkaSaramaClient) ReplicasReturns(result1 []int32, result2 error) {
	fake.replicasMutex.Lock()
	defer fake.replicasMutex.Unlock()
	fake.ReplicasStub = nil
	fake.replicasReturns = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) ReplicasReturnsOnCall(i int, result1 []int32, result2 error) {
	fake.replicasMutex.Lock()
	defer fake.replicasMutex.Unlock()
	fake.ReplicasStub = nil
	if fake.replicasReturnsOnCall == nil {
		fake.replicasReturnsOnCall = make(map[int]struct {
			result1 []int32
			result2 error
		})
	}
	fake.replicasReturnsOnCall[i] = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) Topics() ([]string, error) {
	fake.topicsMutex.Lock()
	ret, specificReturn := fake.topicsReturnsOnCall[len(fake.topicsArgsForCall)]
	fake.topicsArgsForCall = append(fake.topicsArgsForCall, struct {
	}{})
	stub := fake.TopicsStub
	fakeReturns := fake.topicsReturns
	fake.recordInvocation("Topics", []interface{}{})
	fake.topicsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) TopicsCallCount() int {
	fake.topicsMutex.RLock()
	defer fake.topicsMutex.RUnlock()
	return len(fake.topicsArgsForCall)
}

func (fake *KafkaSaramaClient) TopicsCalls(stub func() ([]string, error)) {
	fake.topicsMutex.Lock()
	defer fake.topicsMutex.Unlock()
	fake.TopicsStub = stub
}

func (fake *KafkaSaramaClient) TopicsReturns(result1 []string, result2 error) {
	fake.topicsMutex.Lock()
	defer fake.topicsMutex.Unlock()
	fake.TopicsStub = nil
	fake.topicsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) TopicsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.topicsMutex.Lock()
	defer fake.topicsMutex.Unlock()
	fake.TopicsStub = nil
	if fake.topicsReturnsOnCall == nil {
		fake.topicsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.topicsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) TransactionCoordinator(arg1 string) (*sarama.Broker, error) {
	fake.transactionCoordinatorMutex.Lock()
	ret, specificReturn := fake.transactionCoordinatorReturnsOnCall[len(fake.transactionCoordinatorArgsForCall)]
	fake.transactionCoordinatorArgsForCall = append(fake.transactionCoordinatorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TransactionCoordinatorStub
	fakeReturns := fake.transactionCoordinatorReturns
	fake.recordInvocation("TransactionCoordinator", []interface{}{arg1})
	fake.transactionCoordinatorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) TransactionCoordinatorCallCount() int {
	fake.transactionCoordinatorMutex.RLock()
	defer fake.transactionCoordinatorMutex.RUnlock()
	return len(fake.transactionCoordinatorArgsForCall)
}

func (fake *KafkaSaramaClient) TransactionCoordinatorCalls(stub func(string) (*sarama.Broker, error)) {
	fake.transactionCoordinatorMutex.Lock()
	defer fake.transactionCoordinatorMutex.Unlock()
	fake.TransactionCoordinatorStub = stub
}

func (fake *KafkaSaramaClient) TransactionCoordinatorArgsForCall(i int) string {
	fake.transactionCoordinatorMutex.RLock()
	defer fake.transactionCoordinatorMutex.RUnlock()
	argsForCall := fake.transactionCoordinatorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) TransactionCoordinatorReturns(result1 *sarama.Broker, result2 error) {
	fake.transactionCoordinatorMutex.Lock()
	defer fake.transactionCoordinatorMutex.Unlock()
	fake.TransactionCoordinatorStub = nil
	fake.transactionCoordinatorReturns = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) TransactionCoordinatorReturnsOnCall(i int, result1 *sarama.Broker, result2 error) {
	fake.transactionCoordinatorMutex.Lock()
	defer fake.transactionCoordinatorMutex.Unlock()
	fake.TransactionCoordinatorStub = nil
	if fake.transactionCoordinatorReturnsOnCall == nil {
		fake.transactionCoordinatorReturnsOnCall = make(map[int]struct {
			result1 *sarama.Broker
			result2 error
		})
	}
	fake.transactionCoordinatorReturnsOnCall[i] = struct {
		result1 *sarama.Broker
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) WritablePartitions(arg1 string) ([]int32, error) {
	fake.writablePartitionsMutex.Lock()
	ret, specificReturn := fake.writablePartitionsReturnsOnCall[len(fake.writablePartitionsArgsForCall)]
	fake.writablePartitionsArgsForCall = append(fake.writablePartitionsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WritablePartitionsStub
	fakeReturns := fake.writablePartitionsReturns
	fake.recordInvocation("WritablePartitions", []interface{}{arg1})
	fake.writablePartitionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *KafkaSaramaClient) WritablePartitionsCallCount() int {
	fake.writablePartitionsMutex.RLock()
	defer fake.writablePartitionsMutex.RUnlock()
	return len(fake.writablePartitionsArgsForCall)
}

func (fake *KafkaSaramaClient) WritablePartitionsCalls(stub func(string) ([]int32, error)) {
	fake.writablePartitionsMutex.Lock()
	defer fake.writablePartitionsMutex.Unlock()
	fake.WritablePartitionsStub = stub
}

func (fake *KafkaSaramaClient) WritablePartitionsArgsForCall(i int) string {
	fake.writablePartitionsMutex.RLock()
	defer fake.writablePartitionsMutex.RUnlock()
	argsForCall := fake.writablePartitionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *KafkaSaramaClient) WritablePartitionsReturns(result1 []int32, result2 error) {
	fake.writablePartitionsMutex.Lock()
	defer fake.writablePartitionsMutex.Unlock()
	fake.WritablePartitionsStub = nil
	fake.writablePartitionsReturns = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) WritablePartitionsReturnsOnCall(i int, result1 []int32, result2 error) {
	fake.writablePartitionsMutex.Lock()
	defer fake.writablePartitionsMutex.Unlock()
	fake.WritablePartitionsStub = nil
	if fake.writablePartitionsReturnsOnCall == nil {
		fake.writablePartitionsReturnsOnCall = make(map[int]struct {
			result1 []int32
			result2 error
		})
	}
	fake.writablePartitionsReturnsOnCall[i] = struct {
		result1 []int32
		result2 error
	}{result1, result2}
}

func (fake *KafkaSaramaClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.brokerMutex.RLock()
	defer fake.brokerMutex.RUnlock()
	fake.brokersMutex.RLock()
	defer fake.brokersMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.controllerMutex.RLock()
	defer fake.controllerMutex.RUnlock()
	fake.coordinatorMutex.RLock()
	defer fake.coordinatorMutex.RUnlock()
	fake.getOffsetMutex.RLock()
	defer fake.getOffsetMutex.RUnlock()
	fake.inSyncReplicasMutex.RLock()
	defer fake.inSyncReplicasMutex.RUnlock()
	fake.initProducerIDMutex.RLock()
	defer fake.initProducerIDMutex.RUnlock()
	fake.leaderMutex.RLock()
	defer fake.leaderMutex.RUnlock()
	fake.leaderAndEpochMutex.RLock()
	defer fake.leaderAndEpochMutex.RUnlock()
	fake.leastLoadedBrokerMutex.RLock()
	defer fake.leastLoadedBrokerMutex.RUnlock()
	fake.offlineReplicasMutex.RLock()
	defer fake.offlineReplicasMutex.RUnlock()
	fake.partitionNotReadableMutex.RLock()
	defer fake.partitionNotReadableMutex.RUnlock()
	fake.partitionsMutex.RLock()
	defer fake.partitionsMutex.RUnlock()
	fake.refreshBrokersMutex.RLock()
	defer fake.refreshBrokersMutex.RUnlock()
	fake.refreshControllerMutex.RLock()
	defer fake.refreshControllerMutex.RUnlock()
	fake.refreshCoordinatorMutex.RLock()
	defer fake.refreshCoordinatorMutex.RUnlock()
	fake.refreshMetadataMutex.RLock()
	defer fake.refreshMetadataMutex.RUnlock()
	fake.refreshTransactionCoordinatorMutex.RLock()
	defer fake.refreshTransactionCoordinatorMutex.RUnlock()
	fake.replicasMutex.RLock()
	defer fake.replicasMutex.RUnlock()
	fake.topicsMutex.RLock()
	defer fake.topicsMutex.RUnlock()
	fake.transactionCoordinatorMutex.RLock()
	defer fake.transactionCoordinatorMutex.RUnlock()
	fake.writablePartitionsMutex.RLock()
	defer fake.writablePartitionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *KafkaSaramaClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kafka.SaramaClient = new(KafkaSaramaClient)
